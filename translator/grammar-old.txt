// шпора по квантификаторам:
// n? - 0-или-1 n-символов
// n* - 0-или-больше n-символов
// n - только 1 n-символ
// n+ - 1-или-больше n-символов

Code = 
 val:Operator*
 { return val.filter(v => v) }

Operator
 = Space* val:(
 DoStart / 
 BreakOperator /
 WhileLoopBlock / 
 SwitchBlock / 
 SwitchCaseBlock / 
 SwitchDefaultBlock / 
 ConditionalBlock / 
 VarsDeclaration / 
 AssigmentOperator / 
 CallOperator)? 
 Space* "\n"
 { return val }

BreakOperator
 = Space* 'break'i Space*
 { return { type: "breakOp" } }

ConditionalBlock
 = 'if'i _ cond:Expression Separator
   then:Code?
   els:('else'i _ val:Code { return val })?
   _ 'endif'i
 { return { type: "cond", cond, then: then || [], els: els || [] } }

SwitchCaseBlock
 = 'case'i _ cond:Expression Separator
   body:Code? _
 { return { type: "case", cond, body: body || [] } }

SwitchDefaultBlock
 = 'default' Separator
   body:Code? _
 { return { type: "default", body: body || [] } }

SwitchBlock
 = 'switch'i Separator  cases:SwitchCaseBlock* def:SwitchDefaultBlock? 'endswitch'i
 { return { type: "switch",  cases, def } }

DoStart = 'do'
 { return {type: "doStart" } }

/*
DoUntilBlock
 = 'do'i Separator
 body:Code?
 _ 'until'i Space* cond:Expression Separator
 { return { type: "do", cond, body: body || [] } }
*/

WhileLoopBlock
 = 'while'i _ cond:Expression Separator
   body:Code?
   _ 'endwhile'i
 { return { type: "loop", cond, body: body || [] } }

VarsDeclaration
 = type:VarType local:(IsLocal / NotLocal) names:VarNames
 { return { type: "varsDec", dataType: type, local, names } }

AssigmentOperator 'assigment operator'
  =  to:VariableDef _ op:(':=' / '::=' / '=') _ operand:Operand
  { return { type: "assigmentOp", op, to, operand } }

CallOperator 'function call'
 = name:ValidFunctionName Space* "(" Space* args:CallOperatorArgs? Space* ")"
 { return { type: "callOp", name, args: args || [] } }

UnaryOperator 'unary operator'
 = action:UnaryAction Space* operand:Operand
 { return { type: "unaryOp", action, operand } }

Expression 'expression'
 = '(' Space* operand:Operand Space* ')'
 { return {type: "expression",  operand } }

Const 'constant'
 = value:$("\"" [^\"]* "\"" / "'" [^']* "'" / [-+]?[0-9\.]+ / "#"[0-9]+)
 { return { type: "const", value } }

BinaryOperator 'binary operator'
 = firstOp:_Operand Space* action:BinaryAction Space* secondOp:Operand
 { return { type: "binaryOp", action, operands:[firstOp, secondOp] } }
//Ибо левая рекурсия
_Operand
 = Const / UnaryOperator / Expression / CallOperator / VariableDef
Operand 'operand'
 = BinaryOperator / _Operand

VariableDef 'variable name'
 = isNew:'~'? Space* name:ValidVarName
 { return { type: "variable", isNew: !!isNew, name } } 

CallOperatorArgs
 = first:Operand rest:(',' Space* val:Operand Space* { return val })*
 { return [first].concat(rest) }

ValidFunctionName
 = ValidVarName

UnaryAction
 = '!' / '+' / '-' / '&'

BinaryAction
 = '+' / '-' / '*' / '/' /
   '||' / '|' / '&&' / '&' /
   '>=' / '>' / '<=' / '<' / '==' / '!=' /
   '^' / '%'

//Все что касается блока объявления переменных
VarType = 'HANDLE'i / "STRING"i / "FLOAT"i / "COLORREF"i

IsLocal
 = SpaceOrNewLine+ 'LOCAL'i SpaceOrNewLine+
 { return true }

NotLocal
 = SpaceOrNewLine+
 { return false }

VarNames
 = first:ValidVarName rest:(_ ',' _ value:ValidVarName { return value })*
 { return [first].concat(rest) }

ValidVarName "variable name"
 //= $ ([a-zа-я_]i[_a-zа-я0-9]i*)
 = $ ([_a-zа-я0-9]i+)
 { 
 	const t = text().toLowerCase();
 	if(t === "if") error("missing endif")
    if(t === "while") error("missing endwhile")
    if(t === "case") error("missing switch")
//    if(t === "until") error("missing do")
    return text();
 }
 
//Общее
Separator 'separator'
 = Space* [\n\r] _ {} 
Space "spaces or tabs"
 = [ \t] {}
NewLine "new line" 
 = [\n\r] {}
SpaceOrNewLine "space or tab or new line"
 = [ \t\n\r] {}
_ "whitespace"
 = [ \t\n\r]* {}

//Codelines
// = first:Operator rest:(Separator op:Operator { return op })* Separator?
// { return [first].concat(rest) }
//BinaryOperatorLeft
//= '(' Space* value:OperatorValue Space* ')'
// { return value }
//Separator 'separator'
// = Space* [;\n\r] _ {} 